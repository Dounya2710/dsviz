---
title: "Spatial data and Cartography"
subtitle: ""
author: "Etienne Côme"
lang: en
execute:
  echo: true
format:
  revealjs:
    output-file: lecture-slides.html
    slide-number: true
    menu: false
    progress: false
---

# The spatial eco-system in R

```{r, echo=FALSE}
# Paramétrage différent entre sortie html et revealjs
code_folding = ifelse(knitr::pandoc_to()=="html", "false", "true")
```

```{css}
/*| echo: false */
[id^="section"] .anchored {
  margin: 0;
  border: 0;
  padding:0;
}
[id^="section"] .anchorjs-link {
  display:none;
}
```


```{r installPackages, echo=FALSE, include=FALSE}
## Liste des librairies utilisées
packages <- c("dplyr", "mapview", "sf", "osmdata",
              "RColorBrewer", "ggplot2", "readr",
              "ggspatial", "sfnetworks", "tidygraph", "remotes", 
              "tidygeocoder","btb")
## Vérifier si la librairie est installée, si non l'installer, puis la charger
package.check <- lapply(
  packages,
  FUN = function(x) {
    if (!require(x, character.only = TRUE)) {
      install.packages(x, dependencies = TRUE)
      library(x, character.only = TRUE)
    }
  }
)
```

## Introduction to `sf` 

*  `sf`: [Simple Features for R](https://r-spatial.github.io/sf/index.html)

* sf stands for Simple Features

* Ease the manipulation of spatial data 

* [Tidy data](http://vita.had.co.nz/papers/tidy-data.html): works with the ` |>  ` and dplyr verbs.

* Author : Edzer Pebesma 


## An sf object: 

<img src="img/sf.png" alt="format sf" width="100%">


## Read / write data

Read

Main formats shp, geojson, kml,...

```{r, echo = TRUE, comments = FALSE}
library(sf)
mtq <- read_sf("data/mtq/martinique.shp")
mtq <- st_read("data/mtq/martinique.shp")
```

## Read / write data

Write

```{r, eval = FALSE, echo = TRUE}
#exporter
write_sf(mtq,"data/mtq/martinique.gpkg",delete_layer = TRUE)
st_write(mtq,"data/mtq/martinique.gpkg",delete_layer = TRUE)
```

The gpkg (geopackage) format is open (not linked to an operating system) and implemented as a SQLite database. Also note the existence of the geo-parquet format, which is extremely efficient for processing large volumes of spatial data.


## Coordiantes systems and epsg codes

Projections/coordinate systems are listed using a code called an epsg code:

- lat/long : 4326 [https://epsg.io/4326](https://epsg.io/4326)
- Lambert 93 : 2154 [https://epsg.io/2154](https://epsg.io/2154)
- Pseudo-Mercator : 3857 [https://epsg.io/3857](https://epsg.io/3857)
- Lambert azimuthal equal area : 3035 [https://epsg.io/3035](https://epsg.io/3035)

## Projection 

Get the projection using 'st_crs()' ([epsg code](https://epsg.io/)) and edit it using 'st_transform()'.

<small>
'sf' uses the default spherical geometry for data that has not been projected since version 1.0 thanks to the 's2' library. See [https://r-spatial.github.io](https://r-spatial.github.io/sf/articles/sf7.html) for details.
</small>


```{r}
st_crs(mtq)
mtq_4326 <- mtq |> st_transform(4326)
```



## Ploting

Default:

```{r, nm=TRUE}
plot(mtq)
```

##

Only the geometry:

```{r, nm=TRUE}
plot(st_geometry(mtq))
```

## Centroids

```{r, nm=TRUE}
mtq_c <- st_centroid(mtq) 
plot(st_geometry(mtq))
plot(st_geometry(mtq_c), add = TRUE, cex = 1.2, col = "red", pch = 20)
```

## Distances

```{r, nm=TRUE}
mat <- st_distance(x = mtq_c, y = mtq_c)
mat[1:5, 1:5]
```

## Aggregation 

Union simple  : 

```{r, nm = TRUE}
mtq_u <- st_union(mtq)
plot(st_geometry(mtq), col="lightblue")
plot(st_geometry(mtq_u), add=T, lwd=2, border = "red")
```

##

Using a categorical features, dplyr style:

```{r, nm = TRUE}
library(dplyr)
mtq_u2 <- mtq |> 
  group_by(STATUT) |> 
  summarize(P13_POP = sum(P13_POP))
plot(st_geometry(mtq), col="lightblue")
plot(st_geometry(mtq_u2), add = TRUE, lwd = 2, border = "red", col = NA)
```

## Buffers


```{r, nm = TRUE}
mtq_b <- st_buffer(x = mtq_u, dist = 5000)
plot(st_geometry(mtq), col = "lightblue")
plot(st_geometry(mtq_u), add = TRUE, lwd = 2)
plot(st_geometry(mtq_b), add = TRUE, lwd = 2, border = "red")
```

## Intersections

First lets create a polygon from scratch

```{r, nm=TRUE}
m <- rbind(c(700015,1624212), c(700015,1641586), c(719127,1641586), 
           c(719127,1624212), c(700015,1624212))
p <- st_sf(st_sfc(st_polygon(list(m))), crs = st_crs(mtq))
plot(st_geometry(mtq))
plot(p, border = "red", lwd = 2, add = TRUE)
```

##

'st_intersection()' extracts the part of 'mtq' that intersects with the created polygon.

```{r, nm=TRUE, warning=F}
mtq_z <- st_intersection(x = mtq, y = p)
plot(st_geometry(mtq))
plot(st_geometry(mtq_z), col = "red", border = "green", add = TRUE)
```


## Counts points in polygon !

`st_sample()` sample random points inside the specified geographical object.

```{r , echo = FALSE}
set.seed(1) #Fixer l'aléa pour toujours faire la même carte.
```

```{r, nm=TRUE}
pts <- st_sample(x = mtq, size = 50)
plot(st_geometry(mtq))
plot(pts, pch = 20, col = "red", add=TRUE, cex = 1)
```

##

'st_join' is used to perform a spatial join an aggregation.


<small>
It is possible to fine-tune the join (points on borders,...) with the 'join' argument, which by default is set to 'st_intersects()'. See [here](https://en.wikipedia.org/wiki/DE-9IM) for a precise definition of possible spatial predicates.
</small>

```{r p0a, nm=TRUE}
mtq_counts <- mtq |>
st_join(st_as_sf(pts))

head(mtq_counts |> select(INSEE_COM),3)
```

##

```{r p0b, nm=TRUE}
mtq_counts <- mtq_counts |>
count(INSEE_COM)

head(mtq_counts)
```

##

```{r p0c, nm=TRUE}
plot(mtq_counts|> select(n))
plot(pts, pch = 20, col = "red", add = TRUE, cex = 1)
```

## Voronoi diagram

A Voronoi diagram is a division of the plane into cells (adjacent regions, called Voronoi polygons) from a discrete set of points. Each cell encloses a single point, and forms the set of points in the plane that are closer to that point than to any other.




##

```{r, echo=TRUE,warning=FALSE,message=FALSE,fig.show='last',fig.height=4.5}
mtq_v <- st_collection_extract(st_voronoi(x = st_union(mtq_c)))
mtq_v <- st_intersection(mtq_v, st_union(mtq))
mtq_v <- st_join(x = st_sf(mtq_v), y = mtq_c)
plot(st_geometry(mtq_v), col='lightblue')
```

## Spatial Processing

- st_area(x)
- st_length(x)
- st_disjoint(x, y, sparse = FALSE)
- st_touches(x, y, sparse = FALSE)
- st_crosses(s, s, sparse = FALSE)
- st_within(x, y, sparse = FALSE)
- st_contains(x, y, sparse = FALSE)
- st_overlaps(x, y, sparse = FALSE)

##

- st_equals(x, y, sparse = FALSE)
- st_covers(x, y, sparse = FALSE)
- st_covered_by(x, y, sparse = FALSE)
- st_equals_exact(x, y,0.001, sparse = FALSE)
- ...

## Conversion
- st_cast 
- st_collection_extract
- st_sf
- st_as_sf
- st_as_sfc




# Cartography web and static

In this part, we will visualize data from [road traffic injuries](https://www.data.gouv.fr/fr/datasets/bases-de-donnees-annuelles-des-accidents-corporels-de-la-circulation-routiere-annees-de-2005-a-2019/) from 2019.

## 

It is a 'data.frame' with two columns providing information on the latitude and longitude of road accidents.

```{r}
accidents.2019.paris <- readRDS("data/accidents2019_paris.RDS")
head(accidents.2019.paris)
```

##

You need to convert this 'data.frame' into a spatial object ('sf') using the 'st_as_sf' function. All you have to do is specify the name of the columns containing the coordinates as well as the projection, in this case 'CRS = 4326' (WGS 84). This data is then transformed into 'CRS = 2154' (Lambert 93).

```{r}
accidents.2019.paris <- st_as_sf(accidents.2019.paris,
                                coords = c("long", "lat"),
                                crs = 4326) |>
  st_transform(2154)
```

##

```{r, fig.height=5}
plot(st_geometry(accidents.2019.paris))
```

## Webmaps

Several solutions exist to make interactive maps with R. 'mapview', 'leaflet' and 'mapdeck' are the main ones. For simplicity's sake, we're focusing on 'mapview' here. Interactive maps are not necessarily very relevant for representing geostatistical information. On the other hand, they are useful for exploring databases. Let's look at an example with 'mapview' regarding fatal accidents in Paris in 2019.

##
```{r}
library(mapview)
```

```{r, echo=FALSE}
#pour marcher avec le format .Rmd
mapviewOptions(fgb = FALSE)
# pour ne pas être trop haut dans les slides
mapviewOptions(leafletHeight=400)
```

```{r}
individus_tues <- accidents.2019.paris |>
  filter(grav == 2) |> # grav = 2 : individus tués
  mutate(age=2019-an_nais) # age
mapview(individus_tues)
```


## 

When you click on a dot, the values of the different variables in the database appear. This can help with database exploration. Let's customize a little...

```{r, echo=FALSE}
# pour ne pas être trop haut dans les slides
mapviewOptions(leafletHeight=300)
```

```{r, cache=FALSE}
mapview(individus_tues,
        map.types = "OpenStreetMap.HOT", legend = TRUE,
        cex = 5, col.regions = "#217844", lwd = 0, alpha = 0.9,
        layer.name = 'Individus tués')
```

## 

Let's customize a little more... However, adding a legend for the size of proportional circles is not easy.


```{r, echo=FALSE}
# pour ne pas être trop haut dans les slides
mapviewOptions(leafletHeight=300)
```

```{r, cache=FALSE}
mapview(individus_tues,
        map.types = "OpenStreetMap.HOT", legend=TRUE,
        layer.name = 'Individus tués',
        cex="age", zcol="sexe", lwd=0, alpha=0.9
       )
```

## Cartes statiques avec `ggplot2`

Là encore, différents packages R sont utilisés pour faire des cartes statiques : 

- `ggplot2` est un package très utilisé pour faire tous types de graphiques, et a été adapté spécifiquement aux cartes (`geom_sf`). 
- Le package `tmap` contient des fonctionnalités avancées basées sur la logique de `ggplot2`
- `mapsf` (successeur de `cartography`) s'appuie sur un langage dit "base R" et permet de faire des représentations cartographiques, basiques comme avancées.

## 

Par simplicité, nous nous concentrons ici sur `ggplot2`, package très renommé pour tous types de graphiques.


## Intégrer des données spatiales avec `geom_sf`

Petite introduction / rappel de sémiologie graphique : 

<img src="img/lightsemio.png" alt="Light Semiology" height="400px">

## 

On travaille avec la couche cartographique des IRIS[^1].

[^1]: Les iris sont un zonage statistique de l'Insee dont l'acronyme signifie « Ilots Regroupés pour l'Information Statistique ». Leur taille est de 2000 habitants par unité.

```{r, eval=TRUE,cache=FALSE}
library(sf)
library(dplyr)
iris.75 <- st_read("data/iris_75.shp", stringsAsFactors = F)
```
##

Comptons par iris le nombre de personnes accidentées (`nbacc`) ;

```{r, eval=TRUE, fig.height=5}
acc_iris <- iris.75 |> st_join(accidents.2019.paris) |> 
  group_by(CODE_IRIS) |> dplyr::summarize(nb_acc = n(),
            nb_acc_grav = sum(if_else(grav%in%c(2,3), 1, 0),
                        na.rm = TRUE),
            nb_vl = sum(if_else(catv == "VL seul", 1, 0),
                        na.rm = TRUE),
            nb_edp = sum(if_else(catv == "EDP à moteur", 1, 0),
                         na.rm = TRUE),
            nb_velo = sum(if_else(catv == "Bicyclette", 1, 0),
                          na.rm = TRUE)
            ) 
head(acc_iris,1)
```

##

### Cartes avec ronds proportionnels

```{r, fig.height=4.75, cache=FALSE}
#| code-fold: !expr code_folding

library(ggplot2)
ggplot() +
  geom_sf(data = acc_iris, colour = "ivory3", fill = "ivory") +
  geom_sf(data = acc_iris |>  st_centroid(),
          aes(size= nb_acc), colour="#E84923CC", show.legend = 'point') +
  scale_size(name = "Nombre d'accidents",
             breaks = c(1,10,100,200),
             range = c(0,5)) +
   coord_sf(crs = 2154, datum = NA,
            xlim = st_bbox(iris.75)[c(1,3)],
            ylim = st_bbox(iris.75)[c(2,4)]) +
  theme_minimal() +
  theme(panel.background = element_rect(fill = "ivory",color=NA),
        plot.background = element_rect(fill = "ivory",color=NA),legend.position = "bottom") +
  labs(title = "Nombre d'accidents de la route à Paris par iris",
       caption = "fichier BAAC 2019, ONISR\nantuki & comeetie, 2023",x="",y="")
```

## 

### Cartes choroplèthes

```{r, fig.height=4.75, cache=FALSE}
#| code-fold: !expr code_folding

library(RColorBrewer) #pour les couleurs des palettes
# Quintiles de la part des accidents ayant eu lieu à vélo
perc_velo = 100*acc_iris$nb_velo/acc_iris$nb_acc
bks <- c(0,round(quantile(perc_velo[perc_velo!=0],na.rm=TRUE,probs=seq(0,1,0.25)),1))
# Intégration dans la base de données
acc_iris <- acc_iris |> mutate(txaccvelo = 100*nb_velo/nb_acc,
                     txaccvelo_cat = cut(txaccvelo,bks,include.lowest = TRUE)) 

# Carte
ggplot() +
  geom_sf(data = iris.75,colour = "ivory3",fill = "ivory") +
  geom_sf(data = acc_iris, aes(fill = txaccvelo_cat)) +
  scale_fill_brewer(name = "Part (En %)",
                    palette = "Reds",
                    na.value = "grey80") +
  coord_sf(crs = 2154, datum = NA,
           xlim = st_bbox(iris.75)[c(1,3)],
           ylim = st_bbox(iris.75)[c(2,4)]) +
  theme_minimal() +
  theme(panel.background = element_rect(fill = "ivory",color=NA),
        plot.background = element_rect(fill = "ivory",color=NA),legend.position="bottom") +
  labs(title = "Part des Accidentés à vélos",
       subtitle = "par arrondissement à Paris en 2019",
       caption = "fichier BAAC 2019, ONISR\nantuki & comeetie, 2023",
       x = "", y = "")
```


## Carte avec `mapsf`

Ci-dessous un exemple de carte similaire réalisée avec la syntaxe de la librairie `mapsf`

```{r, fig.height=4.75, warning=FALSE, message=FALSE}
#| code-fold: !expr code_folding

library(mapsf)
mf_theme("default",cex=0.9,mar=c(0,0,1.2,0),bg="ivory")
mf_init(x = acc_iris, expandBB = c(0, 0, 0, .15)) 
mf_map(acc_iris,add = TRUE,col = "ivory2")
# Plot symbols with choropleth coloration
mf_map(
  x = acc_iris |>  st_centroid(),
  var = c("nb_acc", "txaccvelo"),
  type = "prop_choro",
  border = "grey50",
  lwd = 0.1,
  leg_pos = c("topright","right"),
  leg_title = c("Nombre d'accidents", "Part des accidentés à vélo"),
  breaks = c(0,8,15,25,100),
  nbreaks = 5,
  inches= 0.16,
  pal = "Reds",
  leg_val_rnd = c(0, 0),
  leg_frame = c(TRUE, TRUE)
)
mf_layout(
  title = "Nombre d'accidents de la route et proportions d'accidents impliquant des vélos",
  credits = "fichier BAAC 2019, ONISR\nantuki & comeetie, 2023",
  frame = TRUE)
```


<!-- # Un exemple de traitement géomatique avancé -->

<!-- L'objectif de ce traitement est de compter le nombre d'accidents par tronçons de 100m sur le périphérique parisien. -->

<!-- Pour commencer, nous allons extraire des données OSM le squelette du périphérique. Pour ce faire nous allons filtrer le data.frame `roads` à partir d'une liste de noms. Nous aurions pu nous servir d'une petite carte interactive pour trouver cette sélection. -->

<!-- ```{r} -->

<!-- library(dplyr) -->
<!-- library(sf) -->
<!-- library(tidygraph) # equivalent dplyr pour les graphes -->
<!-- library(sfnetworks) # sf + graphes -->
<!-- library(ggplot2) -->

<!-- # A partir de roads, on garde les routes qui correspondent au périphérique -->
<!-- periph_simple <- roads |>  -->
<!--   filter(!is.na(name))|>  -->
<!--   filter(name %in% c("Boulevard Périphérique Intérieur", "Pont Masséna", -->
<!--                      "Tunnel Lilas","Pont Amont","Pont Aval")) |>  -->
<!--   select(name) -->

<!-- plot(periph_simple |> st_geometry(), -->
<!--      col=1:nrow(periph_simple),lwd=4) -->
<!-- ``` -->

<!-- C'est un bon début, mais il reste un certains nombre de problèmes : -->

<!-- - Les lignes extraites ne font pas 100m ; -->
<!-- - Il reste les deux voies parallèles au niveau des tunnels -->


<!-- Pour résoudre ces problèmes, nous allons nous servir de la librairie `sfnetwork`. Elle permet de marier des objets `sf` avec une description de leur topologie sous forme de graphe et elle s'appuie pour cela sur la librairie `tidygraph`. Cette description va nous être bien utile pour fusionner toute les lignes qui se touchent en une grande ligne. Commençons par transformer notre data.frame de lignes en un réseau spatial : -->

<!-- ```{r} -->
<!-- # sfnetwork permet de gérer les réseaux géospatiaux. -->
<!-- # On transforme periph_simple en ce type d'objet -->
<!-- net  = as_sfnetwork(st_geometry(periph_simple)) -->
<!-- plot(net) -->
<!-- ``` -->

<!-- Nous allons maintenant pouvoir supprimer de ce réseau les noeuds inutiles i.e. ceux qui n'ont que deux voisins : -->

<!-- ```{r} -->
<!-- # to_spatial_smooth : on enlève les pseudos-noeuds en  -->
<!-- # préservant la connectivité du réseau -->
<!-- nets = convert(net,to_spatial_smooth) -->
<!-- plot(nets) -->
<!-- ``` -->
<!-- Cela commence à ressembler à quelque chose. Mais il reste encore quelques liens isolés : -->

<!-- ```{r} -->
<!-- plot(nets  |>  -->
<!--        activate(edges) |> -->
<!--        filter(st_length(x)<units::as_units(1000,"m")) -->
<!--      ) -->
<!-- ``` -->
<!-- Pour les supprimer, nous allons calculer la longueur de chaque lien et ne conserver que ceux qui nous permettent de construire une voie continue autour du périphérique : -->

<!-- ```{r} -->
<!-- # On calcule la longueur des edges, on trie par ordre décroissant -->
<!-- nets = nets |>  -->
<!--   activate(edges) |> #on travaille sur les liens (et non les noeuds) -->
<!--   mutate(length=st_length(x)) |>  -->
<!--   arrange(desc(length)) |>  -->
<!--   mutate(lid=1:n()) |>  -->
<!--   filter(lid %in% c(1,2,3,5)) #je ne garde que les grands accès -->
<!-- nets = nets |>  -->
<!--   activate(nodes) |>  -->
<!--   mutate(deg=centrality_degree()) |>  -->
<!--   filter(deg!=0) -->
<!-- nets -->
<!-- plot(nets) -->
<!-- ``` -->

<!-- Nous pouvons maintenant récupérer uniquement la géométrie des liens du réseau, et construire une ligne unique couvrant tout le périphérique : -->

<!-- ```{r} -->
<!-- #On transforme le tout en lignes -->
<!-- lines.geom = nets |> activate(edges) |> st_geometry() -->
<!-- points_ordered = lines.geom[c(2,1,3)] |> st_cast("POINT") -->
<!-- points_ordered = c(points_ordered,points_ordered[1]) -->
<!-- line.geom = points_ordered |> st_combine() |> st_cast("LINESTRING") -->
<!-- line = st_as_sf(line.geom,id=1) -->
<!-- plot(line) -->
<!-- ``` -->

<!-- Il reste a découper cette longue ligne en tronçons de 500m. Pour cela, nous allons commencer par créer un ensemble de points distants de 500m le long de la ligne et uniformiser l’échantillonnage de la ligne : -->

<!-- ```{r} -->
<!-- # On prend une ligne et on met un point tous les 100 mètres -->
<!-- points_eqd = line.geom  |> st_line_sample(density = 1/10) |> -->
<!--   st_cast("POINT") -->
<!-- lines_eqd = line.geom  |> st_line_sample(density = 1/10) |> -->
<!--   st_cast("LINESTRING") -->
<!-- split_points = points_eqd[seq(1,length(points_eqd),by=50)] -->
<!-- plot(points_eqd,pch=20,cex=0.2) -->
<!-- ``` -->

<!-- Ceci va nous permettre de découper la ligne en tronçons de taille identique : -->

<!-- ```{r} -->
<!-- # Je découpe ma ligne avec mes points -->
<!-- troncons.col = lwgeom::st_split(lines_eqd,split_points) -->
<!-- troncons.geom = st_collection_extract(troncons.col,type = "LINESTRING") -->
<!-- troncons = st_sf(troncons.geom,id=1:length(troncons.geom)) -->
<!-- plot(troncons) -->
<!-- st_length(troncons) -->
<!-- ``` -->

<!-- Le plus dur est fait. Il ne reste plus qu'à compter et à faire une carte :). Notez le `endCapStyle` sur le `st_buffer` pour ne pas rajouter de marge aux deux extrémités des tronçons : -->

<!-- ```{r} -->
<!-- # On fait la jointure avec les accidents -->
<!-- periph_count= troncons  |> st_buffer(100,endCapStyle = 'FLAT') |>  -->
<!--   st_join(accidents.2019.paris |> filter(!duplicated(Num_Acc))) |>  -->
<!--   filter(!is.na(Num_Acc)) |>  -->
<!--   count(id) -->

<!-- # On met la bonne géométrie à periph_count -->
<!-- st_geometry(periph_count)=troncons.geom[match(periph_count$id,troncons$id)] -->

<!-- # On fait une carte -->
<!-- ggplot(periph_count) +  -->
<!--   #ggspatial::annotation_map_tile(zoom=13,type="stamenbw") +  -->
<!--   geom_sf(data=roads.geom, colour = "#666666",size=0.5)+ -->
<!--   geom_sf(aes(color=n),size=3)+ -->
<!--   scale_color_distiller("",palette = "Reds",direction=1)+ -->
<!--   coord_sf(crs = 2154, datum = NA) + -->
<!--   theme_minimal() + -->
<!--   theme(panel.background = element_rect(fill = "white",color=NA), -->
<!--         plot.background = element_rect(fill = "white",color=NA)) + -->
<!--   labs(title = "Nombre de personnes accidentées sur le périphérique", -->
<!--        subtitle = "en 2019, par portion de 500m", -->
<!--        caption = "fichier BAAC 2019, ONISR\nantuki & comeetie, 2023",x="",y="") -->

<!-- ``` -->

# Pour aller plus loin

## Lissage spatial

avec le package `btb`

```{r, fig.height=4.75, cache=FALSE}
pts <- accidents.2019.paris |>
  dplyr::mutate(nb_acc = 1) |>
  dplyr::select(nb_acc)
smooth_result <- btb::btb_smooth(pts = pts,
                              sEPSG = 2154,
                              iCellSize = 50, 
                              iBandwidth = 800)
plot(smooth_result |> dplyr::select(nb_acc), border=NA)
```


## Données raster

- [`stars`](https://github.com/r-spatial/stars/) et [`terra`](https://github.com/rspatial/terra) 

![](https://raw.githubusercontent.com/r-spatial/stars/master/images/cube1.png)

## Géocodage

- [`banR`](https://github.com/joelgombin/banR) et [`tidygeocoder`](https://github.com/jessecambon/tidygeocoder)

<!-- evaluation désactivée en raison d'un bug de timeout en intégration continue -->

```{r, eval=TRUE}
library(dplyr, warn.conflicts = FALSE)
library(tidygeocoder)

# create a dataframe with addresses
addresses <- tibble::tribble(
~name,                  ~addr,
"Campus Hannah-Arendt",          "74 Rue Louis Pasteur, 84029 Avignon",
"palais des Papes", "Pl. du Palais, 84000 Avignon"                                
)

# geocode the addresses
lat_longs <- addresses |>
  tidygeocoder::geocode(addr, method = 'osm')
lat_longs
```


## Données OSM

- [`osmdata`](https://github.com/ropensci/osmdata)

```{r}
library(osmdata)
bb = c(4.75, 43.92, 4.85, 43.97) # Avignon
roads <- opq (bbox = bb) |> 
    add_osm_feature (key = "highway") |>
    osmdata_sf()
```

##

```{r}
plot(roads$osm_lines |> dplyr::filter(highway=="primary") |> st_geometry(),lwd=1.5,col="#000000")
plot(roads$osm_lines |> dplyr::filter(highway=="secondary") |> st_geometry(),lwd=1,add=TRUE,col="blue")
plot(roads$osm_lines |> dplyr::filter(highway=="tertiary" | highway=="residential" ) |> st_geometry(),add=TRUE,col="orange")
plot(roads$osm_lines |> dplyr::filter(highway=="living_street" ) |> st_geometry(),add=TRUE,col="red")
```


## Réseaux linéaires et graphes

- [`sfnetworks`](https://luukvdmeer.github.io/sfnetworks/) et [`tidygraph`](https://tidygraph.data-imaginist.com/index.html)

```{r}
library(sfnetworks)
rtype=c("primary","secondary","tertiary","residential")
net = sfnetworks::as_sfnetwork(roads$osm_lines|> dplyr::filter(highway %in% rtype))
plot(net|>activate("edges")|>st_geometry(),col="#444444")
plot(net|>activate("nodes")|>st_geometry(),col="red", cex = 0.2,add=TRUE)
```


## Cartographie interactive

- [`mapdeck`](https://github.com/SymbolixAU/mapdeck)

<p></p>

![](https://github.com/SymbolixAU/mapdeck/raw/master/docs/articles/img/articles/hexagons.png)

## Ressources 

- [rspatial](https://r-spatial.org/)

- [CRAN task views](https://cran.r-project.org/web/views/) permet d'avoir des informations sur les packages du CRAN pertinents pour des tâches reliées à certains sujets. 

##

[CRAN Task View: Analysis of Spatial Data](https://CRAN.R-project.org/view=Spatial):  

- Classes for spatial data   
- Handling spatial data   
- Reading and writing spatial data   
- Visualisation  
- Point pattern analysis  
- Geostatistics  
- Disease mapping and areal data analysis  
- Spatial regression  
- Ecological analysis  

# <small> Crédits et reproductibilité</small> 

Cette formation s'inspire, ainsi que son tutoriel, d'une [précédente formation](https://github.com/comeetie/satRday) donnée par les mêmes auteurs avec Timothée Giraud. 


##

Partage de la configuration de R et des packages utilisés :

```{r}
sessionInfo()
```
